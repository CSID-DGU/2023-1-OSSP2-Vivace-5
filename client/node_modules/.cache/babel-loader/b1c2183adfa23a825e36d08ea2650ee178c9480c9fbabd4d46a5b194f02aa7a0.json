{"ast":null,"code":"// ::- Persistent data structure representing an ordered mapping from\n// strings to values, with some convenient update methods.\nfunction OrderedMap(content) {\n  this.content = content;\n}\nOrderedMap.prototype = {\n  constructor: OrderedMap,\n  find: function (key) {\n    for (var i = 0; i < this.content.length; i += 2) if (this.content[i] === key) return i;\n    return -1;\n  },\n  // :: (string) → ?any\n  // Retrieve the value stored under `key`, or return undefined when\n  // no such key exists.\n  get: function (key) {\n    var found = this.find(key);\n    return found == -1 ? undefined : this.content[found + 1];\n  },\n  // :: (string, any, ?string) → OrderedMap\n  // Create a new map by replacing the value of `key` with a new\n  // value, or adding a binding to the end of the map. If `newKey` is\n  // given, the key of the binding will be replaced with that key.\n  update: function (key, value, newKey) {\n    var self = newKey && newKey != key ? this.remove(newKey) : this;\n    var found = self.find(key),\n      content = self.content.slice();\n    if (found == -1) {\n      content.push(newKey || key, value);\n    } else {\n      content[found + 1] = value;\n      if (newKey) content[found] = newKey;\n    }\n    return new OrderedMap(content);\n  },\n  // :: (string) → OrderedMap\n  // Return a map with the given key removed, if it existed.\n  remove: function (key) {\n    var found = this.find(key);\n    if (found == -1) return this;\n    var content = this.content.slice();\n    content.splice(found, 2);\n    return new OrderedMap(content);\n  },\n  // :: (string, any) → OrderedMap\n  // Add a new key to the start of the map.\n  addToStart: function (key, value) {\n    return new OrderedMap([key, value].concat(this.remove(key).content));\n  },\n  // :: (string, any) → OrderedMap\n  // Add a new key to the end of the map.\n  addToEnd: function (key, value) {\n    var content = this.remove(key).content.slice();\n    content.push(key, value);\n    return new OrderedMap(content);\n  },\n  // :: (string, string, any) → OrderedMap\n  // Add a key after the given key. If `place` is not found, the new\n  // key is added to the end.\n  addBefore: function (place, key, value) {\n    var without = this.remove(key),\n      content = without.content.slice();\n    var found = without.find(place);\n    content.splice(found == -1 ? content.length : found, 0, key, value);\n    return new OrderedMap(content);\n  },\n  // :: ((key: string, value: any))\n  // Call the given function for each key/value pair in the map, in\n  // order.\n  forEach: function (f) {\n    for (var i = 0; i < this.content.length; i += 2) f(this.content[i], this.content[i + 1]);\n  },\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a new map by prepending the keys in this map that don't\n  // appear in `map` before the keys in `map`.\n  prepend: function (map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this;\n    return new OrderedMap(map.content.concat(this.subtract(map).content));\n  },\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a new map by appending the keys in this map that don't\n  // appear in `map` after the keys in `map`.\n  append: function (map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this;\n    return new OrderedMap(this.subtract(map).content.concat(map.content));\n  },\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a map containing all the keys in this map that don't\n  // appear in `map`.\n  subtract: function (map) {\n    var result = this;\n    map = OrderedMap.from(map);\n    for (var i = 0; i < map.content.length; i += 2) result = result.remove(map.content[i]);\n    return result;\n  },\n  // :: () → Object\n  // Turn ordered map into a plain object.\n  toObject: function () {\n    var result = {};\n    this.forEach(function (key, value) {\n      result[key] = value;\n    });\n    return result;\n  },\n  // :: number\n  // The amount of keys in this map.\n  get size() {\n    return this.content.length >> 1;\n  }\n};\n\n// :: (?union<Object, OrderedMap>) → OrderedMap\n// Return a map with the given content. If null, create an empty\n// map. If given an ordered map, return that map itself. If given an\n// object, create a map from the object's properties.\nOrderedMap.from = function (value) {\n  if (value instanceof OrderedMap) return value;\n  var content = [];\n  if (value) for (var prop in value) content.push(prop, value[prop]);\n  return new OrderedMap(content);\n};\nexport default OrderedMap;","map":{"version":3,"names":["OrderedMap","content","prototype","constructor","find","key","i","length","get","found","undefined","update","value","newKey","self","remove","slice","push","splice","addToStart","concat","addToEnd","addBefore","place","without","forEach","f","prepend","map","from","size","subtract","append","result","toObject","prop"],"sources":["C:/Users/leesa/Desktop/OSSP-vivace/tempo/node_modules/orderedmap/dist/index.js"],"sourcesContent":["// ::- Persistent data structure representing an ordered mapping from\n// strings to values, with some convenient update methods.\nfunction OrderedMap(content) {\n  this.content = content;\n}\n\nOrderedMap.prototype = {\n  constructor: OrderedMap,\n\n  find: function(key) {\n    for (var i = 0; i < this.content.length; i += 2)\n      if (this.content[i] === key) return i\n    return -1\n  },\n\n  // :: (string) → ?any\n  // Retrieve the value stored under `key`, or return undefined when\n  // no such key exists.\n  get: function(key) {\n    var found = this.find(key);\n    return found == -1 ? undefined : this.content[found + 1]\n  },\n\n  // :: (string, any, ?string) → OrderedMap\n  // Create a new map by replacing the value of `key` with a new\n  // value, or adding a binding to the end of the map. If `newKey` is\n  // given, the key of the binding will be replaced with that key.\n  update: function(key, value, newKey) {\n    var self = newKey && newKey != key ? this.remove(newKey) : this;\n    var found = self.find(key), content = self.content.slice();\n    if (found == -1) {\n      content.push(newKey || key, value);\n    } else {\n      content[found + 1] = value;\n      if (newKey) content[found] = newKey;\n    }\n    return new OrderedMap(content)\n  },\n\n  // :: (string) → OrderedMap\n  // Return a map with the given key removed, if it existed.\n  remove: function(key) {\n    var found = this.find(key);\n    if (found == -1) return this\n    var content = this.content.slice();\n    content.splice(found, 2);\n    return new OrderedMap(content)\n  },\n\n  // :: (string, any) → OrderedMap\n  // Add a new key to the start of the map.\n  addToStart: function(key, value) {\n    return new OrderedMap([key, value].concat(this.remove(key).content))\n  },\n\n  // :: (string, any) → OrderedMap\n  // Add a new key to the end of the map.\n  addToEnd: function(key, value) {\n    var content = this.remove(key).content.slice();\n    content.push(key, value);\n    return new OrderedMap(content)\n  },\n\n  // :: (string, string, any) → OrderedMap\n  // Add a key after the given key. If `place` is not found, the new\n  // key is added to the end.\n  addBefore: function(place, key, value) {\n    var without = this.remove(key), content = without.content.slice();\n    var found = without.find(place);\n    content.splice(found == -1 ? content.length : found, 0, key, value);\n    return new OrderedMap(content)\n  },\n\n  // :: ((key: string, value: any))\n  // Call the given function for each key/value pair in the map, in\n  // order.\n  forEach: function(f) {\n    for (var i = 0; i < this.content.length; i += 2)\n      f(this.content[i], this.content[i + 1]);\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a new map by prepending the keys in this map that don't\n  // appear in `map` before the keys in `map`.\n  prepend: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this\n    return new OrderedMap(map.content.concat(this.subtract(map).content))\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a new map by appending the keys in this map that don't\n  // appear in `map` after the keys in `map`.\n  append: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this\n    return new OrderedMap(this.subtract(map).content.concat(map.content))\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a map containing all the keys in this map that don't\n  // appear in `map`.\n  subtract: function(map) {\n    var result = this;\n    map = OrderedMap.from(map);\n    for (var i = 0; i < map.content.length; i += 2)\n      result = result.remove(map.content[i]);\n    return result\n  },\n\n  // :: () → Object\n  // Turn ordered map into a plain object.\n  toObject: function() {\n    var result = {};\n    this.forEach(function(key, value) { result[key] = value; });\n    return result\n  },\n\n  // :: number\n  // The amount of keys in this map.\n  get size() {\n    return this.content.length >> 1\n  }\n};\n\n// :: (?union<Object, OrderedMap>) → OrderedMap\n// Return a map with the given content. If null, create an empty\n// map. If given an ordered map, return that map itself. If given an\n// object, create a map from the object's properties.\nOrderedMap.from = function(value) {\n  if (value instanceof OrderedMap) return value\n  var content = [];\n  if (value) for (var prop in value) content.push(prop, value[prop]);\n  return new OrderedMap(content)\n};\n\nexport default OrderedMap;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}