{"ast":null,"code":"/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n\nimport { utils } from \"./utils.js\";\nimport { PolyBezier } from \"./poly-bezier.js\";\n\n// math-inlining.\nconst {\n  abs,\n  min,\n  max,\n  cos,\n  sin,\n  acos,\n  sqrt\n} = Math;\nconst pi = Math.PI;\n// a zero coordinate, which is surprisingly useful\nconst ZERO = {\n  x: 0,\n  y: 0,\n  z: 0\n};\n\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\nclass Bezier {\n  constructor(coords) {\n    let args = coords && coords.forEach ? coords : Array.from(arguments).slice();\n    let coordlen = false;\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      const newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n    let higher = false;\n    const len = args.length;\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\"Only new Bezier(point[]) is accepted for 4th and higher order curves\");\n        }\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\"Only new Bezier(point[]) is accepted for 4th and higher order curves\");\n        }\n      }\n    }\n    const _3d = this._3d = !higher && (len === 9 || len === 12) || coords && coords[0] && typeof coords[0].z !== \"undefined\";\n    const points = this.points = [];\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1]\n      };\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n      points.push(point);\n    }\n    const order = this.order = points.length - 1;\n    const dims = this.dims = [\"x\", \"y\"];\n    if (_3d) dims.push(\"z\");\n    this.dimlen = dims.length;\n\n    // is this curve, practically speaking, a straight line?\n    const aligned = utils.align(points, {\n      p1: points[0],\n      p2: points[order]\n    });\n    const baselength = utils.dist(points[0], points[order]);\n    this._linear = aligned.reduce((t, p) => t + abs(p.y), 0) < baselength / 50;\n    this._lut = [];\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n  static quadraticFromPoints(p1, p2, p3, t) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    // shortcuts, although they're really dumb\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    }\n    // real fitting.\n    const abc = Bezier.getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  }\n  static cubicFromPoints(S, B, E, t, d1) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    const abc = Bezier.getABC(3, S, B, E, t);\n    if (typeof d1 === \"undefined\") {\n      d1 = utils.dist(B, abc.C);\n    }\n    const d2 = d1 * (1 - t) / t;\n    const selen = utils.dist(S, E),\n      lx = (E.x - S.x) / selen,\n      ly = (E.y - S.y) / selen,\n      bx1 = d1 * lx,\n      by1 = d1 * ly,\n      bx2 = d2 * lx,\n      by2 = d2 * ly;\n    // derivation of new hull coordinates\n    const e1 = {\n        x: B.x - bx1,\n        y: B.y - by1\n      },\n      e2 = {\n        x: B.x + bx2,\n        y: B.y + by2\n      },\n      A = abc.A,\n      v1 = {\n        x: A.x + (e1.x - A.x) / (1 - t),\n        y: A.y + (e1.y - A.y) / (1 - t)\n      },\n      v2 = {\n        x: A.x + (e2.x - A.x) / t,\n        y: A.y + (e2.y - A.y) / t\n      },\n      nc1 = {\n        x: S.x + (v1.x - S.x) / t,\n        y: S.y + (v1.y - S.y) / t\n      },\n      nc2 = {\n        x: E.x + (v2.x - E.x) / (1 - t),\n        y: E.y + (v2.y - E.y) / (1 - t)\n      };\n    // ...done\n    return new Bezier(S, nc1, nc2, E);\n  }\n  static getUtils() {\n    return utils;\n  }\n  getUtils() {\n    return Bezier.getUtils();\n  }\n  static get PolyBezier() {\n    return PolyBezier;\n  }\n  valueOf() {\n    return this.toString();\n  }\n  toString() {\n    return utils.pointsToString(this.points);\n  }\n  toSVG() {\n    if (this._3d) return false;\n    const p = this.points,\n      x = p[0].x,\n      y = p[0].y,\n      s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n    return s.join(\" \");\n  }\n  setRatios(ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error(\"incorrect number of ratio values\");\n    }\n    this.ratios = ratios;\n    this._lut = []; //  invalidate any precomputed LUT\n  }\n\n  verify() {\n    const print = this.coordDigest();\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n  coordDigest() {\n    return this.points.map(function (c, pos) {\n      return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n    }).join(\"\");\n  }\n  update() {\n    // invalidate any precomputed LUT\n    this._lut = [];\n    this.dpoints = utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n  computedirection() {\n    const points = this.points;\n    const angle = utils.angle(points[0], points[this.order], points[1]);\n    this.clockwise = angle > 0;\n  }\n  length() {\n    return utils.length(this.derivative.bind(this));\n  }\n  static getABC() {\n    let order = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n    let S = arguments.length > 1 ? arguments[1] : undefined;\n    let B = arguments.length > 2 ? arguments[2] : undefined;\n    let E = arguments.length > 3 ? arguments[3] : undefined;\n    let t = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n    const u = utils.projectionratio(t, order),\n      um = 1 - u,\n      C = {\n        x: u * S.x + um * E.x,\n        y: u * S.y + um * E.y\n      },\n      s = utils.abcratio(t, order),\n      A = {\n        x: B.x + (B.x - C.x) / s,\n        y: B.y + (B.y - C.y) / s\n      };\n    return {\n      A,\n      B,\n      C,\n      S,\n      E\n    };\n  }\n  getABC(t, B) {\n    B = B || this.get(t);\n    let S = this.points[0];\n    let E = this.points[this.order];\n    return Bezier.getABC(this.order, S, B, E, t);\n  }\n  getLUT(steps) {\n    this.verify();\n    steps = steps || 100;\n    if (this._lut.length === steps + 1) {\n      return this._lut;\n    }\n    this._lut = [];\n    // n steps means n+1 points\n    steps++;\n    this._lut = [];\n    for (let i = 0, p, t; i < steps; i++) {\n      t = i / (steps - 1);\n      p = this.compute(t);\n      p.t = t;\n      this._lut.push(p);\n    }\n    return this._lut;\n  }\n  on(point, error) {\n    error = error || 5;\n    const lut = this.getLUT(),\n      hits = [];\n    for (let i = 0, c, t = 0; i < lut.length; i++) {\n      c = lut[i];\n      if (utils.dist(c, point) < error) {\n        hits.push(c);\n        t += i / lut.length;\n      }\n    }\n    if (!hits.length) return false;\n    return t /= hits.length;\n  }\n  project(point) {\n    // step 1: coarse check\n    const LUT = this.getLUT(),\n      l = LUT.length - 1,\n      closest = utils.closest(LUT, point),\n      mpos = closest.mpos,\n      t1 = (mpos - 1) / l,\n      t2 = (mpos + 1) / l,\n      step = 0.1 / l;\n\n    // step 2: fine check\n    let mdist = closest.mdist,\n      t = t1,\n      ft = t,\n      p;\n    mdist += 1;\n    for (let d; t < t2 + step; t += step) {\n      p = this.compute(t);\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        ft = t;\n      }\n    }\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n    return p;\n  }\n  get(t) {\n    return this.compute(t);\n  }\n  point(idx) {\n    return this.points[idx];\n  }\n  compute(t) {\n    if (this.ratios) {\n      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n    }\n    return utils.compute(t, this.points, this._3d, this.ratios);\n  }\n  raise() {\n    const p = this.points,\n      np = [p[0]],\n      k = p.length;\n    for (let i = 1, pi, pim; i < k; i++) {\n      pi = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: (k - i) / k * pi.x + i / k * pim.x,\n        y: (k - i) / k * pi.y + i / k * pim.y\n      };\n    }\n    np[k] = p[k - 1];\n    return new Bezier(np);\n  }\n  derivative(t) {\n    return utils.compute(t, this.dpoints[0], this._3d);\n  }\n  dderivative(t) {\n    return utils.compute(t, this.dpoints[1], this._3d);\n  }\n  align() {\n    let p = this.points;\n    return new Bezier(utils.align(p, {\n      p1: p[0],\n      p2: p[p.length - 1]\n    }));\n  }\n  curvature(t) {\n    return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n  }\n  inflections() {\n    return utils.inflections(this.points);\n  }\n  normal(t) {\n    return this._3d ? this.__normal3(t) : this.__normal2(t);\n  }\n  __normal2(t) {\n    const d = this.derivative(t);\n    const q = sqrt(d.x * d.x + d.y * d.y);\n    return {\n      t,\n      x: -d.y / q,\n      y: d.x / q\n    };\n  }\n  __normal3(t) {\n    // see http://stackoverflow.com/questions/25453159\n    const r1 = this.derivative(t),\n      r2 = this.derivative(t + 0.01),\n      q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n      q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2;\n    // cross product\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x\n    };\n    const m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);\n    c.x /= m;\n    c.y /= m;\n    c.z /= m;\n    // rotation matrix\n    const R = [c.x * c.x, c.x * c.y - c.z, c.x * c.z + c.y, c.x * c.y + c.z, c.y * c.y, c.y * c.z - c.x, c.x * c.z - c.y, c.y * c.z + c.x, c.z * c.z];\n    // normal vector:\n    const n = {\n      t,\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z\n    };\n    return n;\n  }\n  hull(t) {\n    let p = this.points,\n      _p = [],\n      q = [],\n      idx = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    }\n    // we lerp between all points at each iteration, until we have 1 point left.\n    while (p.length > 1) {\n      _p = [];\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\n        pt = utils.lerp(t, p[i], p[i + 1]);\n        q[idx++] = pt;\n        _p.push(pt);\n      }\n      p = _p;\n    }\n    return q;\n  }\n  split(t1, t2) {\n    // shortcuts\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n    if (t2 === 1) {\n      return this.split(t1).right;\n    }\n\n    // no shortcut: use \"de Casteljau\" iteration.\n    const q = this.hull(t1);\n    const result = {\n      left: this.order === 2 ? new Bezier([q[0], q[3], q[5]]) : new Bezier([q[0], q[4], q[7], q[9]]),\n      right: this.order === 2 ? new Bezier([q[5], q[4], q[2]]) : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q\n    };\n\n    // make sure we bind _t1/_t2 information!\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);\n\n    // if we have no t2, we're done\n    if (!t2) {\n      return result;\n    }\n\n    // if we have a t2, split again:\n    t2 = utils.map(t2, t1, 1, 0, 1);\n    return result.right.split(t2).left;\n  }\n  extrema() {\n    const result = {};\n    let roots = [];\n    this.dims.forEach(function (dim) {\n      let mfn = function (v) {\n        return v[dim];\n      };\n      let p = this.dpoints[0].map(mfn);\n      result[dim] = utils.droots(p);\n      if (this.order === 3) {\n        p = this.dpoints[1].map(mfn);\n        result[dim] = result[dim].concat(utils.droots(p));\n      }\n      result[dim] = result[dim].filter(function (t) {\n        return t >= 0 && t <= 1;\n      });\n      roots = roots.concat(result[dim].sort(utils.numberSort));\n    }.bind(this));\n    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n    return result;\n  }\n  bbox() {\n    const extrema = this.extrema(),\n      result = {};\n    this.dims.forEach(function (d) {\n      result[d] = utils.getminmax(this, d, extrema[d]);\n    }.bind(this));\n    return result;\n  }\n  overlaps(curve) {\n    const lbbox = this.bbox(),\n      tbbox = curve.bbox();\n    return utils.bboxoverlap(lbbox, tbbox);\n  }\n  offset(t, d) {\n    if (typeof d !== \"undefined\") {\n      const c = this.get(t),\n        n = this.normal(t);\n      const ret = {\n        c: c,\n        n: n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d\n      };\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n      return ret;\n    }\n    if (this._linear) {\n      const nv = this.normal(0),\n        coords = this.points.map(function (p) {\n          const ret = {\n            x: p.x + t * nv.x,\n            y: p.y + t * nv.y\n          };\n          if (p.z && nv.z) {\n            ret.z = p.z + t * nv.z;\n          }\n          return ret;\n        });\n      return [new Bezier(coords)];\n    }\n    return this.reduce().map(function (s) {\n      if (s._linear) {\n        return s.offset(t)[0];\n      }\n      return s.scale(t);\n    });\n  }\n  simple() {\n    if (this.order === 3) {\n      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n      if (a1 > 0 && a2 < 0 || a1 < 0 && a2 > 0) return false;\n    }\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n    let s = n1.x * n2.x + n1.y * n2.y;\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n    return abs(acos(s)) < pi / 3;\n  }\n  reduce() {\n    // TODO: examine these var types in more detail...\n    let i,\n      t1 = 0,\n      t2 = 0,\n      step = 0.01,\n      segment,\n      pass1 = [],\n      pass2 = [];\n    // first pass: split on extrema\n    let extrema = this.extrema().values;\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    }\n\n    // second pass: further reduce these segments to simple segments\n    pass1.forEach(function (p1) {\n      t1 = 0;\n      t2 = 0;\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n          if (!segment.simple()) {\n            t2 -= step;\n            if (abs(t1 - t2) < step) {\n              // we can never form a reduction\n              return [];\n            }\n            segment = p1.split(t1, t2);\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n  translate(v, d1, d2) {\n    d2 = typeof d2 === \"number\" ? d2 : d1;\n\n    // TODO: make this take curves with control points outside\n    //       of the start-end interval into account\n\n    const o = this.order;\n    let d = this.points.map((_, i) => (1 - i / o) * d1 + i / o * d2);\n    return new Bezier(this.points.map((p, i) => ({\n      x: p.x + v.x * d[i],\n      y: p.y + v.y * d[i]\n    })));\n  }\n  scale(d) {\n    const order = this.order;\n    let distanceFn = false;\n    if (typeof d === \"function\") {\n      distanceFn = d;\n    }\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    }\n\n    // TODO: add special handling for non-linear degenerate curves.\n\n    const clockwise = this.clockwise;\n    const points = this.points;\n    if (this._linear) {\n      return this.translate(this.normal(0), distanceFn ? distanceFn(0) : d, distanceFn ? distanceFn(1) : d);\n    }\n    const r1 = distanceFn ? distanceFn(0) : d;\n    const r2 = distanceFn ? distanceFn(1) : d;\n    const v = [this.offset(0, 10), this.offset(1, 10)];\n    const np = [];\n    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n    if (!o) {\n      throw new Error(\"cannot scale this curve. Try reducing it first.\");\n    }\n\n    // move all points by distance 'd' wrt the origin 'o',\n    // and move end points by fixed distance along normal.\n    [0, 1].forEach(function (t) {\n      const p = np[t * order] = utils.copy(points[t * order]);\n      p.x += (t ? r2 : r1) * v[t].n.x;\n      p.y += (t ? r2 : r1) * v[t].n.y;\n    });\n    if (!distanceFn) {\n      // move control points to lie on the intersection of the offset\n      // derivative vector, and the origin-through-control vector\n      [0, 1].forEach(t => {\n        if (order === 2 && !!t) return;\n        const p = np[t * order];\n        const d = this.derivative(t);\n        const p2 = {\n          x: p.x + d.x,\n          y: p.y + d.y\n        };\n        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n      });\n      return new Bezier(np);\n    }\n\n    // move control points by \"however much necessary to\n    // ensure the correct tangent to endpoint\".\n    [0, 1].forEach(function (t) {\n      if (order === 2 && !!t) return;\n      var p = points[t + 1];\n      var ov = {\n        x: p.x - o.x,\n        y: p.y - o.y\n      };\n      var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n      if (distanceFn && !clockwise) rc = -rc;\n      var m = sqrt(ov.x * ov.x + ov.y * ov.y);\n      ov.x /= m;\n      ov.y /= m;\n      np[t + 1] = {\n        x: p.x + rc * ov.x,\n        y: p.y + rc * ov.y\n      };\n    });\n    return new Bezier(np);\n  }\n  outline(d1, d2, d3, d4) {\n    d2 = d2 === undefined ? d1 : d2;\n    if (this._linear) {\n      // TODO: find the actual extrema, because they might\n      //       be before the start, or past the end.\n\n      const n = this.normal(0);\n      const start = this.points[0];\n      const end = this.points[this.points.length - 1];\n      let s, mid, e;\n      if (d3 === undefined) {\n        d3 = d1;\n        d4 = d2;\n      }\n      s = {\n        x: start.x + n.x * d1,\n        y: start.y + n.y * d1\n      };\n      e = {\n        x: end.x + n.x * d3,\n        y: end.y + n.y * d3\n      };\n      mid = {\n        x: (s.x + e.x) / 2,\n        y: (s.y + e.y) / 2\n      };\n      const fline = [s, mid, e];\n      s = {\n        x: start.x - n.x * d2,\n        y: start.y - n.y * d2\n      };\n      e = {\n        x: end.x - n.x * d4,\n        y: end.y - n.y * d4\n      };\n      mid = {\n        x: (s.x + e.x) / 2,\n        y: (s.y + e.y) / 2\n      };\n      const bline = [e, mid, s];\n      const ls = utils.makeline(bline[2], fline[0]);\n      const le = utils.makeline(fline[2], bline[0]);\n      const segments = [ls, new Bezier(fline), le, new Bezier(bline)];\n      return new PolyBezier(segments);\n    }\n    const reduced = this.reduce(),\n      len = reduced.length,\n      fcurves = [];\n    let bcurves = [],\n      p,\n      alen = 0,\n      tlen = this.length();\n    const graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n    function linearDistanceFunction(s, e, tlen, alen, slen) {\n      return function (v) {\n        const f1 = alen / tlen,\n          f2 = (alen + slen) / tlen,\n          d = e - s;\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    }\n\n    // form curve oulines\n    reduced.forEach(function (segment) {\n      const slen = segment.length();\n      if (graduated) {\n        fcurves.push(segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen)));\n        bcurves.push(segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen)));\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n      alen += slen;\n    });\n\n    // reverse the \"return\" outline\n    bcurves = bcurves.map(function (s) {\n      p = s.points;\n      if (p[3]) {\n        s.points = [p[3], p[2], p[1], p[0]];\n      } else {\n        s.points = [p[2], p[1], p[0]];\n      }\n      return s;\n    }).reverse();\n\n    // form the endcaps as lines\n    const fs = fcurves[0].points[0],\n      fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n      bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n      be = bcurves[0].points[0],\n      ls = utils.makeline(bs, fs),\n      le = utils.makeline(fe, be),\n      segments = [ls].concat(fcurves).concat([le]).concat(bcurves);\n    return new PolyBezier(segments);\n  }\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    const outline = this.outline(d1, d2).curves;\n    const shapes = [];\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\n      const shape = utils.makeshape(outline[i], outline[len - i], curveIntersectionThreshold);\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n    return shapes;\n  }\n  intersects(curve, curveIntersectionThreshold) {\n    if (!curve) return this.selfintersects(curveIntersectionThreshold);\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n    return this.curveintersects(this.reduce(), curve, curveIntersectionThreshold);\n  }\n  lineIntersects(line) {\n    const mx = min(line.p1.x, line.p2.x),\n      my = min(line.p1.y, line.p2.y),\n      MX = max(line.p1.x, line.p2.x),\n      MY = max(line.p1.y, line.p2.y);\n    return utils.roots(this.points, line).filter(t => {\n      var p = this.get(t);\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n    });\n  }\n  selfintersects(curveIntersectionThreshold) {\n    // \"simple\" curves cannot intersect with their direct\n    // neighbour, so for each segment X we check whether\n    // it intersects [0:x-2][x+2:last].\n\n    const reduced = this.reduce(),\n      len = reduced.length - 2,\n      results = [];\n    for (let i = 0, result, left, right; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results.push(...result);\n    }\n    return results;\n  }\n  curveintersects(c1, c2, curveIntersectionThreshold) {\n    const pairs = [];\n    // step 1: pair off any overlapping segments\n    c1.forEach(function (l) {\n      c2.forEach(function (r) {\n        if (l.overlaps(r)) {\n          pairs.push({\n            left: l,\n            right: r\n          });\n        }\n      });\n    });\n    // step 2: for each pairing, run through the convergence algorithm.\n    let intersections = [];\n    pairs.forEach(function (pair) {\n      const result = utils.pairiteration(pair.left, pair.right, curveIntersectionThreshold);\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n  arcs(errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    return this._iterate(errorThreshold, []);\n  }\n  _error(pc, np1, s, e) {\n    const q = (e - s) / 4,\n      c1 = this.get(s + q),\n      c2 = this.get(e - q),\n      ref = utils.dist(pc, np1),\n      d1 = utils.dist(pc, c1),\n      d2 = utils.dist(pc, c2);\n    return abs(d1 - ref) + abs(d2 - ref);\n  }\n  _iterate(errorThreshold, circles) {\n    let t_s = 0,\n      t_e = 1,\n      safety;\n    // we do a binary search to find the \"good `t` closest to no-longer-good\"\n    do {\n      safety = 0;\n\n      // step 1: start with the maximum possible arc\n      t_e = 1;\n\n      // points:\n      let np1 = this.get(t_s),\n        np2,\n        np3,\n        arc,\n        prev_arc;\n\n      // booleans:\n      let curr_good = false,\n        prev_good = false,\n        done;\n\n      // numbers:\n      let t_m = t_e,\n        prev_e = 1,\n        step = 0;\n\n      // step 2: find the best possible arc\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n        step++;\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n        arc = utils.getccenter(np1, np2, np3);\n\n        //also save the t values\n        arc.interval = {\n          start: t_s,\n          end: t_e\n        };\n        let error = this._error(arc, np1, t_s, t_e);\n        curr_good = error <= errorThreshold;\n        done = prev_good && !curr_good;\n        if (!done) prev_e = t_e;\n\n        // this arc is fine: we can move 'e' up to see if we can find a wider arc\n        if (curr_good) {\n          // if e is already at max, then we're done for this arc.\n          if (t_e >= 1) {\n            // make sure we cap at t=1\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc;\n            // if we capped the arc segment to t=1 we also need to make sure that\n            // the arc's end angle is correct with respect to the bezier end point.\n            if (t_e > 1) {\n              let d = {\n                x: arc.x + arc.r * cos(arc.e),\n                y: arc.y + arc.r * sin(arc.e)\n              };\n              arc.e += utils.angle({\n                x: arc.x,\n                y: arc.y\n              }, d, this.get(1));\n            }\n            break;\n          }\n          // if not, move it up by half the iteration distance\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          // this is a bad arc: we need to move 'e' down to find a good arc\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n      if (safety >= 100) {\n        break;\n      }\n\n      // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n      prev_arc = prev_arc ? prev_arc : arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n    return circles;\n  }\n}\nexport { Bezier };","map":{"version":3,"names":["utils","PolyBezier","abs","min","max","cos","sin","acos","sqrt","Math","pi","PI","ZERO","x","y","z","Bezier","constructor","coords","args","forEach","Array","from","arguments","slice","coordlen","length","newargs","point","d","push","higher","len","Error","_3d","points","idx","step","order","dims","dimlen","aligned","align","p1","p2","baselength","dist","_linear","reduce","t","p","_lut","_t1","_t2","update","quadraticFromPoints","p3","abc","getABC","A","cubicFromPoints","S","B","E","d1","C","d2","selen","lx","ly","bx1","by1","bx2","by2","e1","e2","v1","v2","nc1","nc2","getUtils","valueOf","toString","pointsToString","toSVG","s","i","last","join","setRatios","ratios","verify","print","coordDigest","_print","map","c","pos","dpoints","derive","computedirection","angle","clockwise","derivative","bind","undefined","u","projectionratio","um","abcratio","get","getLUT","steps","compute","on","error","lut","hits","project","LUT","l","closest","mpos","t1","t2","mdist","ft","computeWithRatios","raise","np","k","pim","dderivative","curvature","inflections","normal","__normal3","__normal2","q","r1","r2","q1","q2","m","R","n","hull","_p","pt","lerp","split","left","right","result","span","extrema","roots","dim","mfn","v","droots","concat","filter","sort","numberSort","values","indexOf","bbox","getminmax","overlaps","curve","lbbox","tbbox","bboxoverlap","offset","ret","nv","scale","simple","a1","a2","n1","n2","segment","pass1","pass2","translate","o","_","distanceFn","lli4","copy","ov","rc","outline","d3","d4","start","end","mid","e","fline","bline","ls","makeline","le","segments","reduced","fcurves","bcurves","alen","tlen","graduated","linearDistanceFunction","slen","f1","f2","reverse","fs","fe","bs","be","outlineshapes","curveIntersectionThreshold","curves","shapes","shape","makeshape","startcap","virtual","endcap","intersects","selfintersects","lineIntersects","curveintersects","line","mx","my","MX","MY","between","results","c1","c2","pairs","r","intersections","pair","pairiteration","arcs","errorThreshold","_iterate","_error","pc","np1","ref","circles","t_s","t_e","safety","np2","np3","arc","prev_arc","curr_good","prev_good","done","t_m","prev_e","getccenter","interval"],"sources":["C:/Users/leesa/Desktop/OSSP-vivace/tempo/node_modules/bezier-js/src/bezier.js"],"sourcesContent":["/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n\nimport { utils } from \"./utils.js\";\nimport { PolyBezier } from \"./poly-bezier.js\";\n\n// math-inlining.\nconst { abs, min, max, cos, sin, acos, sqrt } = Math;\nconst pi = Math.PI;\n// a zero coordinate, which is surprisingly useful\nconst ZERO = { x: 0, y: 0, z: 0 };\n\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\nclass Bezier {\n  constructor(coords) {\n    let args =\n      coords && coords.forEach ? coords : Array.from(arguments).slice();\n    let coordlen = false;\n\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      const newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    let higher = false;\n    const len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n      }\n    }\n\n    const _3d = (this._3d =\n      (!higher && (len === 9 || len === 12)) ||\n      (coords && coords[0] && typeof coords[0].z !== \"undefined\"));\n\n    const points = (this.points = []);\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1],\n      };\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n      points.push(point);\n    }\n    const order = (this.order = points.length - 1);\n\n    const dims = (this.dims = [\"x\", \"y\"]);\n    if (_3d) dims.push(\"z\");\n    this.dimlen = dims.length;\n\n    // is this curve, practically speaking, a straight line?\n    const aligned = utils.align(points, { p1: points[0], p2: points[order] });\n    const baselength = utils.dist(points[0], points[order]);\n    this._linear = aligned.reduce((t, p) => t + abs(p.y), 0) < baselength / 50;\n\n    this._lut = [];\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n\n  static quadraticFromPoints(p1, p2, p3, t) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    // shortcuts, although they're really dumb\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    }\n    // real fitting.\n    const abc = Bezier.getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  }\n\n  static cubicFromPoints(S, B, E, t, d1) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    const abc = Bezier.getABC(3, S, B, E, t);\n    if (typeof d1 === \"undefined\") {\n      d1 = utils.dist(B, abc.C);\n    }\n    const d2 = (d1 * (1 - t)) / t;\n\n    const selen = utils.dist(S, E),\n      lx = (E.x - S.x) / selen,\n      ly = (E.y - S.y) / selen,\n      bx1 = d1 * lx,\n      by1 = d1 * ly,\n      bx2 = d2 * lx,\n      by2 = d2 * ly;\n    // derivation of new hull coordinates\n    const e1 = { x: B.x - bx1, y: B.y - by1 },\n      e2 = { x: B.x + bx2, y: B.y + by2 },\n      A = abc.A,\n      v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) },\n      v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t },\n      nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t },\n      nc2 = {\n        x: E.x + (v2.x - E.x) / (1 - t),\n        y: E.y + (v2.y - E.y) / (1 - t),\n      };\n    // ...done\n    return new Bezier(S, nc1, nc2, E);\n  }\n\n  static getUtils() {\n    return utils;\n  }\n\n  getUtils() {\n    return Bezier.getUtils();\n  }\n\n  static get PolyBezier() {\n    return PolyBezier;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return utils.pointsToString(this.points);\n  }\n\n  toSVG() {\n    if (this._3d) return false;\n    const p = this.points,\n      x = p[0].x,\n      y = p[0].y,\n      s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n    return s.join(\" \");\n  }\n\n  setRatios(ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error(\"incorrect number of ratio values\");\n    }\n    this.ratios = ratios;\n    this._lut = []; //  invalidate any precomputed LUT\n  }\n\n  verify() {\n    const print = this.coordDigest();\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n\n  coordDigest() {\n    return this.points\n      .map(function (c, pos) {\n        return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n      })\n      .join(\"\");\n  }\n\n  update() {\n    // invalidate any precomputed LUT\n    this._lut = [];\n    this.dpoints = utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n\n  computedirection() {\n    const points = this.points;\n    const angle = utils.angle(points[0], points[this.order], points[1]);\n    this.clockwise = angle > 0;\n  }\n\n  length() {\n    return utils.length(this.derivative.bind(this));\n  }\n\n  static getABC(order = 2, S, B, E, t = 0.5) {\n    const u = utils.projectionratio(t, order),\n      um = 1 - u,\n      C = {\n        x: u * S.x + um * E.x,\n        y: u * S.y + um * E.y,\n      },\n      s = utils.abcratio(t, order),\n      A = {\n        x: B.x + (B.x - C.x) / s,\n        y: B.y + (B.y - C.y) / s,\n      };\n    return { A, B, C, S, E };\n  }\n\n  getABC(t, B) {\n    B = B || this.get(t);\n    let S = this.points[0];\n    let E = this.points[this.order];\n    return Bezier.getABC(this.order, S, B, E, t);\n  }\n\n  getLUT(steps) {\n    this.verify();\n    steps = steps || 100;\n    if (this._lut.length === steps + 1) {\n      return this._lut;\n    }\n    this._lut = [];\n    // n steps means n+1 points\n    steps++;\n    this._lut = [];\n    for (let i = 0, p, t; i < steps; i++) {\n      t = i / (steps - 1);\n      p = this.compute(t);\n      p.t = t;\n      this._lut.push(p);\n    }\n    return this._lut;\n  }\n\n  on(point, error) {\n    error = error || 5;\n    const lut = this.getLUT(),\n      hits = [];\n    for (let i = 0, c, t = 0; i < lut.length; i++) {\n      c = lut[i];\n      if (utils.dist(c, point) < error) {\n        hits.push(c);\n        t += i / lut.length;\n      }\n    }\n    if (!hits.length) return false;\n    return (t /= hits.length);\n  }\n\n  project(point) {\n    // step 1: coarse check\n    const LUT = this.getLUT(),\n      l = LUT.length - 1,\n      closest = utils.closest(LUT, point),\n      mpos = closest.mpos,\n      t1 = (mpos - 1) / l,\n      t2 = (mpos + 1) / l,\n      step = 0.1 / l;\n\n    // step 2: fine check\n    let mdist = closest.mdist,\n      t = t1,\n      ft = t,\n      p;\n    mdist += 1;\n    for (let d; t < t2 + step; t += step) {\n      p = this.compute(t);\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        ft = t;\n      }\n    }\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n    return p;\n  }\n\n  get(t) {\n    return this.compute(t);\n  }\n\n  point(idx) {\n    return this.points[idx];\n  }\n\n  compute(t) {\n    if (this.ratios) {\n      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n    }\n    return utils.compute(t, this.points, this._3d, this.ratios);\n  }\n\n  raise() {\n    const p = this.points,\n      np = [p[0]],\n      k = p.length;\n    for (let i = 1, pi, pim; i < k; i++) {\n      pi = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: ((k - i) / k) * pi.x + (i / k) * pim.x,\n        y: ((k - i) / k) * pi.y + (i / k) * pim.y,\n      };\n    }\n    np[k] = p[k - 1];\n    return new Bezier(np);\n  }\n\n  derivative(t) {\n    return utils.compute(t, this.dpoints[0], this._3d);\n  }\n\n  dderivative(t) {\n    return utils.compute(t, this.dpoints[1], this._3d);\n  }\n\n  align() {\n    let p = this.points;\n    return new Bezier(utils.align(p, { p1: p[0], p2: p[p.length - 1] }));\n  }\n\n  curvature(t) {\n    return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n  }\n\n  inflections() {\n    return utils.inflections(this.points);\n  }\n\n  normal(t) {\n    return this._3d ? this.__normal3(t) : this.__normal2(t);\n  }\n\n  __normal2(t) {\n    const d = this.derivative(t);\n    const q = sqrt(d.x * d.x + d.y * d.y);\n    return { t, x: -d.y / q, y: d.x / q };\n  }\n\n  __normal3(t) {\n    // see http://stackoverflow.com/questions/25453159\n    const r1 = this.derivative(t),\n      r2 = this.derivative(t + 0.01),\n      q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n      q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2;\n    // cross product\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x,\n    };\n    const m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);\n    c.x /= m;\n    c.y /= m;\n    c.z /= m;\n    // rotation matrix\n    const R = [\n      c.x * c.x,\n      c.x * c.y - c.z,\n      c.x * c.z + c.y,\n      c.x * c.y + c.z,\n      c.y * c.y,\n      c.y * c.z - c.x,\n      c.x * c.z - c.y,\n      c.y * c.z + c.x,\n      c.z * c.z,\n    ];\n    // normal vector:\n    const n = {\n      t,\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z,\n    };\n    return n;\n  }\n\n  hull(t) {\n    let p = this.points,\n      _p = [],\n      q = [],\n      idx = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    }\n    // we lerp between all points at each iteration, until we have 1 point left.\n    while (p.length > 1) {\n      _p = [];\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\n        pt = utils.lerp(t, p[i], p[i + 1]);\n        q[idx++] = pt;\n        _p.push(pt);\n      }\n      p = _p;\n    }\n    return q;\n  }\n\n  split(t1, t2) {\n    // shortcuts\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n    if (t2 === 1) {\n      return this.split(t1).right;\n    }\n\n    // no shortcut: use \"de Casteljau\" iteration.\n    const q = this.hull(t1);\n    const result = {\n      left:\n        this.order === 2\n          ? new Bezier([q[0], q[3], q[5]])\n          : new Bezier([q[0], q[4], q[7], q[9]]),\n      right:\n        this.order === 2\n          ? new Bezier([q[5], q[4], q[2]])\n          : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q,\n    };\n\n    // make sure we bind _t1/_t2 information!\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);\n\n    // if we have no t2, we're done\n    if (!t2) {\n      return result;\n    }\n\n    // if we have a t2, split again:\n    t2 = utils.map(t2, t1, 1, 0, 1);\n    return result.right.split(t2).left;\n  }\n\n  extrema() {\n    const result = {};\n    let roots = [];\n\n    this.dims.forEach(\n      function (dim) {\n        let mfn = function (v) {\n          return v[dim];\n        };\n        let p = this.dpoints[0].map(mfn);\n        result[dim] = utils.droots(p);\n        if (this.order === 3) {\n          p = this.dpoints[1].map(mfn);\n          result[dim] = result[dim].concat(utils.droots(p));\n        }\n        result[dim] = result[dim].filter(function (t) {\n          return t >= 0 && t <= 1;\n        });\n        roots = roots.concat(result[dim].sort(utils.numberSort));\n      }.bind(this)\n    );\n\n    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n\n    return result;\n  }\n\n  bbox() {\n    const extrema = this.extrema(),\n      result = {};\n    this.dims.forEach(\n      function (d) {\n        result[d] = utils.getminmax(this, d, extrema[d]);\n      }.bind(this)\n    );\n    return result;\n  }\n\n  overlaps(curve) {\n    const lbbox = this.bbox(),\n      tbbox = curve.bbox();\n    return utils.bboxoverlap(lbbox, tbbox);\n  }\n\n  offset(t, d) {\n    if (typeof d !== \"undefined\") {\n      const c = this.get(t),\n        n = this.normal(t);\n      const ret = {\n        c: c,\n        n: n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d,\n      };\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n      return ret;\n    }\n    if (this._linear) {\n      const nv = this.normal(0),\n        coords = this.points.map(function (p) {\n          const ret = {\n            x: p.x + t * nv.x,\n            y: p.y + t * nv.y,\n          };\n          if (p.z && nv.z) {\n            ret.z = p.z + t * nv.z;\n          }\n          return ret;\n        });\n      return [new Bezier(coords)];\n    }\n    return this.reduce().map(function (s) {\n      if (s._linear) {\n        return s.offset(t)[0];\n      }\n      return s.scale(t);\n    });\n  }\n\n  simple() {\n    if (this.order === 3) {\n      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n      if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;\n    }\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n    let s = n1.x * n2.x + n1.y * n2.y;\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n    return abs(acos(s)) < pi / 3;\n  }\n\n  reduce() {\n    // TODO: examine these var types in more detail...\n    let i,\n      t1 = 0,\n      t2 = 0,\n      step = 0.01,\n      segment,\n      pass1 = [],\n      pass2 = [];\n    // first pass: split on extrema\n    let extrema = this.extrema().values;\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    }\n\n    // second pass: further reduce these segments to simple segments\n    pass1.forEach(function (p1) {\n      t1 = 0;\n      t2 = 0;\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n          if (!segment.simple()) {\n            t2 -= step;\n            if (abs(t1 - t2) < step) {\n              // we can never form a reduction\n              return [];\n            }\n            segment = p1.split(t1, t2);\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n\n  translate(v, d1, d2) {\n    d2 = typeof d2 === \"number\" ? d2 : d1;\n\n    // TODO: make this take curves with control points outside\n    //       of the start-end interval into account\n\n    const o = this.order;\n    let d = this.points.map((_, i) => (1 - i / o) * d1 + (i / o) * d2);\n    return new Bezier(\n      this.points.map((p, i) => ({\n        x: p.x + v.x * d[i],\n        y: p.y + v.y * d[i],\n      }))\n    );\n  }\n\n  scale(d) {\n    const order = this.order;\n    let distanceFn = false;\n    if (typeof d === \"function\") {\n      distanceFn = d;\n    }\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    }\n\n    // TODO: add special handling for non-linear degenerate curves.\n\n    const clockwise = this.clockwise;\n    const points = this.points;\n\n    if (this._linear) {\n      return this.translate(\n        this.normal(0),\n        distanceFn ? distanceFn(0) : d,\n        distanceFn ? distanceFn(1) : d\n      );\n    }\n\n    const r1 = distanceFn ? distanceFn(0) : d;\n    const r2 = distanceFn ? distanceFn(1) : d;\n    const v = [this.offset(0, 10), this.offset(1, 10)];\n    const np = [];\n    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n\n    if (!o) {\n      throw new Error(\"cannot scale this curve. Try reducing it first.\");\n    }\n\n    // move all points by distance 'd' wrt the origin 'o',\n    // and move end points by fixed distance along normal.\n    [0, 1].forEach(function (t) {\n      const p = (np[t * order] = utils.copy(points[t * order]));\n      p.x += (t ? r2 : r1) * v[t].n.x;\n      p.y += (t ? r2 : r1) * v[t].n.y;\n    });\n\n    if (!distanceFn) {\n      // move control points to lie on the intersection of the offset\n      // derivative vector, and the origin-through-control vector\n      [0, 1].forEach((t) => {\n        if (order === 2 && !!t) return;\n        const p = np[t * order];\n        const d = this.derivative(t);\n        const p2 = { x: p.x + d.x, y: p.y + d.y };\n        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n      });\n      return new Bezier(np);\n    }\n\n    // move control points by \"however much necessary to\n    // ensure the correct tangent to endpoint\".\n    [0, 1].forEach(function (t) {\n      if (order === 2 && !!t) return;\n      var p = points[t + 1];\n      var ov = {\n        x: p.x - o.x,\n        y: p.y - o.y,\n      };\n      var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n      if (distanceFn && !clockwise) rc = -rc;\n      var m = sqrt(ov.x * ov.x + ov.y * ov.y);\n      ov.x /= m;\n      ov.y /= m;\n      np[t + 1] = {\n        x: p.x + rc * ov.x,\n        y: p.y + rc * ov.y,\n      };\n    });\n    return new Bezier(np);\n  }\n\n  outline(d1, d2, d3, d4) {\n    d2 = d2 === undefined ? d1 : d2;\n\n    if (this._linear) {\n      // TODO: find the actual extrema, because they might\n      //       be before the start, or past the end.\n\n      const n = this.normal(0);\n      const start = this.points[0];\n      const end = this.points[this.points.length - 1];\n      let s, mid, e;\n\n      if (d3 === undefined) {\n        d3 = d1;\n        d4 = d2;\n      }\n\n      s = { x: start.x + n.x * d1, y: start.y + n.y * d1 };\n      e = { x: end.x + n.x * d3, y: end.y + n.y * d3 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const fline = [s, mid, e];\n\n      s = { x: start.x - n.x * d2, y: start.y - n.y * d2 };\n      e = { x: end.x - n.x * d4, y: end.y - n.y * d4 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const bline = [e, mid, s];\n\n      const ls = utils.makeline(bline[2], fline[0]);\n      const le = utils.makeline(fline[2], bline[0]);\n      const segments = [ls, new Bezier(fline), le, new Bezier(bline)];\n      return new PolyBezier(segments);\n    }\n\n    const reduced = this.reduce(),\n      len = reduced.length,\n      fcurves = [];\n\n    let bcurves = [],\n      p,\n      alen = 0,\n      tlen = this.length();\n\n    const graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n\n    function linearDistanceFunction(s, e, tlen, alen, slen) {\n      return function (v) {\n        const f1 = alen / tlen,\n          f2 = (alen + slen) / tlen,\n          d = e - s;\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    }\n\n    // form curve oulines\n    reduced.forEach(function (segment) {\n      const slen = segment.length();\n      if (graduated) {\n        fcurves.push(\n          segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))\n        );\n        bcurves.push(\n          segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))\n        );\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n      alen += slen;\n    });\n\n    // reverse the \"return\" outline\n    bcurves = bcurves\n      .map(function (s) {\n        p = s.points;\n        if (p[3]) {\n          s.points = [p[3], p[2], p[1], p[0]];\n        } else {\n          s.points = [p[2], p[1], p[0]];\n        }\n        return s;\n      })\n      .reverse();\n\n    // form the endcaps as lines\n    const fs = fcurves[0].points[0],\n      fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n      bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n      be = bcurves[0].points[0],\n      ls = utils.makeline(bs, fs),\n      le = utils.makeline(fe, be),\n      segments = [ls].concat(fcurves).concat([le]).concat(bcurves);\n\n    return new PolyBezier(segments);\n  }\n\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    const outline = this.outline(d1, d2).curves;\n    const shapes = [];\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\n      const shape = utils.makeshape(\n        outline[i],\n        outline[len - i],\n        curveIntersectionThreshold\n      );\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n    return shapes;\n  }\n\n  intersects(curve, curveIntersectionThreshold) {\n    if (!curve) return this.selfintersects(curveIntersectionThreshold);\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n    return this.curveintersects(\n      this.reduce(),\n      curve,\n      curveIntersectionThreshold\n    );\n  }\n\n  lineIntersects(line) {\n    const mx = min(line.p1.x, line.p2.x),\n      my = min(line.p1.y, line.p2.y),\n      MX = max(line.p1.x, line.p2.x),\n      MY = max(line.p1.y, line.p2.y);\n    return utils.roots(this.points, line).filter((t) => {\n      var p = this.get(t);\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n    });\n  }\n\n  selfintersects(curveIntersectionThreshold) {\n    // \"simple\" curves cannot intersect with their direct\n    // neighbour, so for each segment X we check whether\n    // it intersects [0:x-2][x+2:last].\n\n    const reduced = this.reduce(),\n      len = reduced.length - 2,\n      results = [];\n\n    for (let i = 0, result, left, right; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results.push(...result);\n    }\n    return results;\n  }\n\n  curveintersects(c1, c2, curveIntersectionThreshold) {\n    const pairs = [];\n    // step 1: pair off any overlapping segments\n    c1.forEach(function (l) {\n      c2.forEach(function (r) {\n        if (l.overlaps(r)) {\n          pairs.push({ left: l, right: r });\n        }\n      });\n    });\n    // step 2: for each pairing, run through the convergence algorithm.\n    let intersections = [];\n    pairs.forEach(function (pair) {\n      const result = utils.pairiteration(\n        pair.left,\n        pair.right,\n        curveIntersectionThreshold\n      );\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n\n  arcs(errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    return this._iterate(errorThreshold, []);\n  }\n\n  _error(pc, np1, s, e) {\n    const q = (e - s) / 4,\n      c1 = this.get(s + q),\n      c2 = this.get(e - q),\n      ref = utils.dist(pc, np1),\n      d1 = utils.dist(pc, c1),\n      d2 = utils.dist(pc, c2);\n    return abs(d1 - ref) + abs(d2 - ref);\n  }\n\n  _iterate(errorThreshold, circles) {\n    let t_s = 0,\n      t_e = 1,\n      safety;\n    // we do a binary search to find the \"good `t` closest to no-longer-good\"\n    do {\n      safety = 0;\n\n      // step 1: start with the maximum possible arc\n      t_e = 1;\n\n      // points:\n      let np1 = this.get(t_s),\n        np2,\n        np3,\n        arc,\n        prev_arc;\n\n      // booleans:\n      let curr_good = false,\n        prev_good = false,\n        done;\n\n      // numbers:\n      let t_m = t_e,\n        prev_e = 1,\n        step = 0;\n\n      // step 2: find the best possible arc\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n        step++;\n\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n\n        arc = utils.getccenter(np1, np2, np3);\n\n        //also save the t values\n        arc.interval = {\n          start: t_s,\n          end: t_e,\n        };\n\n        let error = this._error(arc, np1, t_s, t_e);\n        curr_good = error <= errorThreshold;\n\n        done = prev_good && !curr_good;\n        if (!done) prev_e = t_e;\n\n        // this arc is fine: we can move 'e' up to see if we can find a wider arc\n        if (curr_good) {\n          // if e is already at max, then we're done for this arc.\n          if (t_e >= 1) {\n            // make sure we cap at t=1\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc;\n            // if we capped the arc segment to t=1 we also need to make sure that\n            // the arc's end angle is correct with respect to the bezier end point.\n            if (t_e > 1) {\n              let d = {\n                x: arc.x + arc.r * cos(arc.e),\n                y: arc.y + arc.r * sin(arc.e),\n              };\n              arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));\n            }\n            break;\n          }\n          // if not, move it up by half the iteration distance\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          // this is a bad arc: we need to move 'e' down to find a good arc\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n\n      if (safety >= 100) {\n        break;\n      }\n\n      // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n      prev_arc = prev_arc ? prev_arc : arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n    return circles;\n  }\n}\n\nexport { Bezier };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}